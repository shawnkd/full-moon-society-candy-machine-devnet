{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reducer = void 0;\n\nconst react_1 = require(\"react\");\n\nconst utils_1 = require(\"../useReducer/utils\");\n\nconst config_1 = require(\"../config\");\n\nconst logger_1 = __importDefault(require(\"../logger\"));\n\nconst types_1 = require(\"../types\");\n\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'refresh_status_check':\n      {\n        return Object.assign(Object.assign({}, state), {\n          walletPowoInProgress: false,\n          powoFinished: false,\n          powoRequested: undefined,\n          refreshInProgress: true,\n          refreshIntervalId: action.refreshIntervalId,\n          walletToRefresh: action.walletToRefresh,\n          refreshTokenState: types_1.RefreshTokenState.CHECK_TOKEN_EXPIRATION\n        });\n      }\n\n    case 'refresh_start':\n      {\n        return Object.assign(Object.assign({}, state), {\n          gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED,\n          refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS\n        });\n      }\n\n    case 'refresh_complete':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.COMPLETED,\n          gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken),\n          civicPass: Object.assign(Object.assign({}, state.civicPass), {\n            responsePayload: undefined\n          })\n        });\n      }\n\n    case 'refresh_with_powo_in_progress':\n      {\n        return Object.assign(Object.assign({}, state), {\n          renderIframe: false,\n          iframeMinimized: true,\n          gatewayStatus: types_1.GatewayStatus.COLLECTING_USER_INFORMATION\n        });\n      }\n\n    case 'refresh_clear_interval':\n      return Object.assign(Object.assign({}, state), {\n        refreshIntervalId: undefined\n      });\n\n    case 'refresh_set_interval':\n      return Object.assign(Object.assign({}, state), {\n        refreshIntervalId: action.refreshIntervalId\n      });\n\n    default:\n      return state;\n  }\n};\n\nexports.reducer = reducer;\n\nconst useRefresh = (_ref, state, dispatch) => {\n  let {\n    stage,\n    gatekeeperClient\n  } = _ref;\n  const {\n    refreshIntervalId,\n    gatewayToken\n  } = state;\n\n  const logDebug = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(`[useRefresh] ${message}`, obj);\n  };\n\n  const logError = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.error(`[useRefresh] ${message}`, obj);\n  };\n  /**\n   * if a refresh interval hasn't already been set, create one that will dispatch the startRefresh\n   * event, triggering the refreshFlow\n   */\n\n\n  const setRefreshPoll = (0, react_1.useCallback)(connectedWallet => {\n    if (!refreshIntervalId) {\n      const interval = setInterval(() => {\n        dispatch({\n          type: 'refresh_status_check',\n          refreshIntervalId: interval,\n          walletToRefresh: connectedWallet\n        });\n      }, (0, config_1.getRefreshIntervalMs)(stage)); // this will be cleared on completion\n      // We need to know that the interval was set even if it has not fired yet.\n      // to avoid setting duplicate intervals.\n\n      dispatch({\n        type: 'refresh_set_interval',\n        refreshIntervalId: interval\n      });\n      logger_1.default.debug('setRefreshPoll setInterval', (0, config_1.getRefreshIntervalMs)(stage));\n    }\n  }, [refreshIntervalId, stage]);\n  /**\n   * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n   * endpoint.\n   * On server error (5xx), retry with backoff.\n   * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n   */\n\n  const refreshTokenWithProof = (0, react_1.useCallback)(useWallet => _ref2 => {\n    let {\n      proof,\n      payload\n    } = _ref2;\n    return new Promise((resolve, reject) => {\n      logDebug('Refresh token with proof', proof);\n\n      if (gatewayToken) {\n        dispatch({\n          type: 'refresh_with_powo_in_progress'\n        });\n        gatekeeperClient().refreshToken(gatewayToken.identifier, useWallet.publicKey, payload, proof).then(() => {\n          resolve();\n        }).catch(error => {\n          logError('Error refreshing token with proof', error);\n          reject(error);\n        });\n      }\n    });\n  }, [gatewayToken, gatekeeperClient, setRefreshPoll]);\n  return {\n    setRefreshPoll,\n    refreshTokenWithProof\n  };\n};\n\nexports.default = useRefresh;","map":{"version":3,"sources":["/Users/shawn/metaplex/js/packages/candy-machine-ui/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useRefresh.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","reducer","react_1","require","utils_1","config_1","logger_1","types_1","state","action","type","assign","walletPowoInProgress","powoFinished","powoRequested","undefined","refreshInProgress","refreshIntervalId","walletToRefresh","refreshTokenState","RefreshTokenState","CHECK_TOKEN_EXPIRATION","gatewayStatus","GatewayStatus","REFRESH_TOKEN_REQUIRED","IN_PROGRESS","COMPLETED","statusFromToken","gatewayToken","civicPass","responsePayload","renderIframe","iframeMinimized","COLLECTING_USER_INFORMATION","useRefresh","dispatch","stage","gatekeeperClient","logDebug","message","obj","default","debug","logError","error","setRefreshPoll","useCallback","connectedWallet","interval","setInterval","getRefreshIntervalMs","refreshTokenWithProof","useWallet","proof","payload","Promise","resolve","reject","refreshToken","identifier","publicKey","then","catch"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reducer = void 0;\nconst react_1 = require(\"react\");\nconst utils_1 = require(\"../useReducer/utils\");\nconst config_1 = require(\"../config\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst types_1 = require(\"../types\");\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case 'refresh_status_check': {\n            return Object.assign(Object.assign({}, state), { walletPowoInProgress: false, powoFinished: false, powoRequested: undefined, refreshInProgress: true, refreshIntervalId: action.refreshIntervalId, walletToRefresh: action.walletToRefresh, refreshTokenState: types_1.RefreshTokenState.CHECK_TOKEN_EXPIRATION });\n        }\n        case 'refresh_start': {\n            return Object.assign(Object.assign({}, state), { gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED, refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS });\n        }\n        case 'refresh_complete': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.COMPLETED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken), civicPass: Object.assign(Object.assign({}, state.civicPass), { responsePayload: undefined }) });\n        }\n        case 'refresh_with_powo_in_progress': {\n            return Object.assign(Object.assign({}, state), { renderIframe: false, iframeMinimized: true, gatewayStatus: types_1.GatewayStatus.COLLECTING_USER_INFORMATION });\n        }\n        case 'refresh_clear_interval':\n            return Object.assign(Object.assign({}, state), { refreshIntervalId: undefined });\n        case 'refresh_set_interval':\n            return Object.assign(Object.assign({}, state), { refreshIntervalId: action.refreshIntervalId });\n        default:\n            return state;\n    }\n};\nexports.reducer = reducer;\nconst useRefresh = ({ stage, gatekeeperClient }, state, dispatch) => {\n    const { refreshIntervalId, gatewayToken } = state;\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useRefresh] ${message}`, obj);\n    const logError = (message, obj = null) => logger_1.default.error(`[useRefresh] ${message}`, obj);\n    /**\n     * if a refresh interval hasn't already been set, create one that will dispatch the startRefresh\n     * event, triggering the refreshFlow\n     */\n    const setRefreshPoll = (0, react_1.useCallback)((connectedWallet) => {\n        if (!refreshIntervalId) {\n            const interval = setInterval(() => {\n                dispatch({\n                    type: 'refresh_status_check',\n                    refreshIntervalId: interval,\n                    walletToRefresh: connectedWallet,\n                });\n            }, (0, config_1.getRefreshIntervalMs)(stage)); // this will be cleared on completion\n            // We need to know that the interval was set even if it has not fired yet.\n            // to avoid setting duplicate intervals.\n            dispatch({\n                type: 'refresh_set_interval',\n                refreshIntervalId: interval,\n            });\n            logger_1.default.debug('setRefreshPoll setInterval', (0, config_1.getRefreshIntervalMs)(stage));\n        }\n    }, [refreshIntervalId, stage]);\n    /**\n     * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n     * endpoint.\n     * On server error (5xx), retry with backoff.\n     * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n     */\n    const refreshTokenWithProof = (0, react_1.useCallback)((useWallet) => ({ proof, payload }) => {\n        return new Promise((resolve, reject) => {\n            logDebug('Refresh token with proof', proof);\n            if (gatewayToken) {\n                dispatch({ type: 'refresh_with_powo_in_progress' });\n                gatekeeperClient()\n                    .refreshToken(gatewayToken.identifier, useWallet.publicKey, payload, proof)\n                    .then(() => {\n                    resolve();\n                })\n                    .catch((error) => {\n                    logError('Error refreshing token with proof', error);\n                    reject(error);\n                });\n            }\n        });\n    }, [gatewayToken, gatekeeperClient, setRefreshPoll]);\n    return {\n        setRefreshPoll,\n        refreshTokenWithProof,\n    };\n};\nexports.default = useRefresh;\n"]},"metadata":{},"sourceType":"script"}