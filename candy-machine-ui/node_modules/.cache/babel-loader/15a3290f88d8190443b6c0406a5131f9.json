{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reducer = void 0;\n\nconst react_1 = require(\"react\");\n\nconst R = __importStar(require(\"ramda\"));\n\nconst types_1 = require(\"../types\");\n\nconst logger_1 = __importDefault(require(\"../logger\"));\n\nconst useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\n\nconst networkConfig_1 = __importDefault(require(\"../networkConfig\"));\n\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'getGatekeeperRecord':\n      return Object.assign(Object.assign({}, state), {\n        gatewayStatus: types_1.GatewayStatus.CHECKING,\n        gatekeeperRecordState: undefined\n      });\n\n    case 'getGatekeeperRecord_failure':\n      return Object.assign(Object.assign({}, state), {\n        gatekeeperRecordState: action.gatekeeperRecord.state\n      });\n\n    case 'getGatekeeperRecord_success':\n      return Object.assign(Object.assign({}, state), {\n        gatekeeperRecordState: action.gatekeeperRecord.state,\n        civicPass: Object.assign(Object.assign({}, state.civicPass), {\n          requestPayload: action.gatekeeperRecord.payload\n        })\n      });\n\n    case 'getGatekeeperRecord_location_not_supported':\n      return Object.assign(Object.assign({}, state), {\n        gatewayStatus: types_1.GatewayStatus.LOCATION_NOT_SUPPORTED,\n        gatekeeperRecordState: action.gatekeeperRecord.state,\n        civicPass: Object.assign(Object.assign({}, state.civicPass), {\n          requestPayload: action.gatekeeperRecord.payload\n        })\n      });\n\n    case 'getGatekeeperRecord_issued_location_not_supported':\n      return Object.assign(Object.assign({}, state), {\n        gatewayStatus: types_1.GatewayStatus.LOCATION_NOT_SUPPORTED,\n        gatekeeperRecordState: action.gatekeeperRecord.state,\n        civicPass: Object.assign(Object.assign({}, state.civicPass), {\n          requestPayload: action.gatekeeperRecord.payload\n        })\n      });\n\n    case 'getGatekeeperRecord_not_found':\n      return Object.assign(Object.assign({}, state), {\n        gatewayStatus: types_1.GatewayStatus.NOT_REQUESTED,\n        gatekeeperRecordState: action.gatekeeperRecord.state\n      });\n\n    default:\n      return state;\n  }\n};\n\nexports.reducer = reducer;\n\nconst useGetGatekeeperRecord = (_ref, state, dispatch) => {\n  let {\n    wallet,\n    gatekeeperClient,\n    httpConfig\n  } = _ref;\n  const {\n    expectWalletConnected\n  } = (0, useWalletHooks_1.default)(wallet, state, dispatch);\n\n  const logDebug = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(`[useGetGatekeeperRecord] ${message}`, obj);\n  };\n\n  const {\n    gatewayToken,\n    gatekeeperNetworkAddress\n  } = state;\n  const config = (0, networkConfig_1.default)(gatekeeperNetworkAddress);\n\n  const dispatchFetch = () => ({\n    type: 'getGatekeeperRecord'\n  });\n\n  const dispatchFailure = () => ({\n    type: 'getGatekeeperRecord_failure',\n    gatekeeperRecord: {\n      state: types_1.GatekeeperRecordState.SERVER_FAILURE,\n      payload: undefined\n    }\n  });\n\n  const dispatchSuccess = record => ({\n    type: 'getGatekeeperRecord_success',\n    gatekeeperRecord: record\n  });\n\n  const dispatchLocationNotSupported = record => ({\n    type: 'getGatekeeperRecord_location_not_supported',\n    gatekeeperRecord: record\n  });\n\n  const dispatchIssuedLocationNotSupported = record => ({\n    type: 'getGatekeeperRecord_issued_location_not_supported',\n    gatekeeperRecord: record\n  });\n\n  const dispatchRecordNotFound = record => ({\n    type: 'getGatekeeperRecord_not_found',\n    gatekeeperRecord: record\n  });\n\n  const getAction = gatekeeperRecordState => {\n    const actions = {\n      [types_1.GatekeeperRecordState.REQUESTED]: () => dispatchSuccess(gatekeeperRecordState),\n      [types_1.GatekeeperRecordState.ISSUED]: () => dispatchSuccess(gatekeeperRecordState),\n      [types_1.GatekeeperRecordState.ISSUED_EXPIRED]: () => dispatchSuccess(gatekeeperRecordState),\n      [types_1.GatekeeperRecordState.ISSUED_EXPIRY_APPROACHING]: () => dispatchSuccess(gatekeeperRecordState),\n      [types_1.GatekeeperRecordState.ISSUED_LOCATION_NOT_SUPPORTED]: () => dispatchIssuedLocationNotSupported(gatekeeperRecordState),\n      [types_1.GatekeeperRecordState.LOCATION_NOT_SUPPORTED]: () => dispatchLocationNotSupported(gatekeeperRecordState),\n      [types_1.GatekeeperRecordState.NOT_REQUESTED]: () => dispatchRecordNotFound(gatekeeperRecordState)\n    };\n    return actions[gatekeeperRecordState.state];\n  };\n  /**\n   * Check to see if there is getGatekeeperRecord and dispatch actions based on the state of the record.\n   * If the service call fails dispatch a failure.\n   */\n\n\n  const dispatchGatekeeperRecord = async () => {\n    const walletAddress = expectWalletConnected();\n    logDebug('Fetching Gatekeeper record');\n    dispatch(dispatchFetch());\n\n    try {\n      const record = await gatekeeperClient().getGatekeeperRecordWithPayload(walletAddress.publicKey);\n      logDebug('Gatekeeper record response state: ', types_1.GatekeeperRecordState[record.state]);\n      const action = getAction(record);\n\n      if (!action) {\n        logger_1.default.error('Cannot dispatch action for invalid Gatekeeper Record State.', {\n          record\n        });\n        return;\n      }\n\n      dispatch(action());\n    } catch (error) {\n      logger_1.default.error('Failed to fetch Gatekeeper record', error);\n      dispatch(dispatchFailure());\n      throw error;\n    }\n  };\n\n  const useHttpConfigRef = newHttpConfig => {\n    const ref = (0, react_1.useRef)(); // We have to perform a deep equality check, otherwise useEffect will run every time the httpConfig object reference changes.\n\n    if (!R.equals(newHttpConfig, ref.current)) {\n      ref.current = newHttpConfig;\n    }\n\n    return ref.current;\n  };\n\n  (0, react_1.useEffect)(() => {\n    if (config.requiresGatekeeperRecordStatusCheck) {\n      dispatchGatekeeperRecord();\n    }\n  }, [gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.state, gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, gatekeeperNetworkAddress, useHttpConfigRef(httpConfig), config.requiresGatekeeperRecordStatusCheck]);\n  return {\n    dispatchGatekeeperRecord\n  };\n};\n\nexports.default = useGetGatekeeperRecord;","map":{"version":3,"sources":["/Users/shawn/solana-dev/FMS_CM/candy-machine-ui/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useGatekeeperRecord.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","prototype","hasOwnProperty","call","__importDefault","exports","reducer","react_1","require","R","types_1","logger_1","useWalletHooks_1","networkConfig_1","state","action","type","assign","gatewayStatus","GatewayStatus","CHECKING","gatekeeperRecordState","gatekeeperRecord","civicPass","requestPayload","payload","LOCATION_NOT_SUPPORTED","NOT_REQUESTED","useGetGatekeeperRecord","dispatch","wallet","gatekeeperClient","httpConfig","expectWalletConnected","default","logDebug","message","obj","debug","gatewayToken","gatekeeperNetworkAddress","config","dispatchFetch","dispatchFailure","GatekeeperRecordState","SERVER_FAILURE","dispatchSuccess","record","dispatchLocationNotSupported","dispatchIssuedLocationNotSupported","dispatchRecordNotFound","getAction","actions","REQUESTED","ISSUED","ISSUED_EXPIRED","ISSUED_EXPIRY_APPROACHING","ISSUED_LOCATION_NOT_SUPPORTED","dispatchGatekeeperRecord","walletAddress","getGatekeeperRecordWithPayload","publicKey","error","useHttpConfigRef","newHttpConfig","ref","useRef","equals","current","useEffect","requiresGatekeeperRecordStatusCheck","expiryTime"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reducer = void 0;\nconst react_1 = require(\"react\");\nconst R = __importStar(require(\"ramda\"));\nconst types_1 = require(\"../types\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\nconst networkConfig_1 = __importDefault(require(\"../networkConfig\"));\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case 'getGatekeeperRecord':\n            return Object.assign(Object.assign({}, state), { gatewayStatus: types_1.GatewayStatus.CHECKING, gatekeeperRecordState: undefined });\n        case 'getGatekeeperRecord_failure':\n            return Object.assign(Object.assign({}, state), { gatekeeperRecordState: action.gatekeeperRecord.state });\n        case 'getGatekeeperRecord_success':\n            return Object.assign(Object.assign({}, state), { gatekeeperRecordState: action.gatekeeperRecord.state, civicPass: Object.assign(Object.assign({}, state.civicPass), { requestPayload: action.gatekeeperRecord.payload }) });\n        case 'getGatekeeperRecord_location_not_supported':\n            return Object.assign(Object.assign({}, state), { gatewayStatus: types_1.GatewayStatus.LOCATION_NOT_SUPPORTED, gatekeeperRecordState: action.gatekeeperRecord.state, civicPass: Object.assign(Object.assign({}, state.civicPass), { requestPayload: action.gatekeeperRecord.payload }) });\n        case 'getGatekeeperRecord_issued_location_not_supported':\n            return Object.assign(Object.assign({}, state), { gatewayStatus: types_1.GatewayStatus.LOCATION_NOT_SUPPORTED, gatekeeperRecordState: action.gatekeeperRecord.state, civicPass: Object.assign(Object.assign({}, state.civicPass), { requestPayload: action.gatekeeperRecord.payload }) });\n        case 'getGatekeeperRecord_not_found':\n            return Object.assign(Object.assign({}, state), { gatewayStatus: types_1.GatewayStatus.NOT_REQUESTED, gatekeeperRecordState: action.gatekeeperRecord.state });\n        default:\n            return state;\n    }\n};\nexports.reducer = reducer;\nconst useGetGatekeeperRecord = ({ wallet, gatekeeperClient, httpConfig, }, state, dispatch) => {\n    const { expectWalletConnected } = (0, useWalletHooks_1.default)(wallet, state, dispatch);\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useGetGatekeeperRecord] ${message}`, obj);\n    const { gatewayToken, gatekeeperNetworkAddress } = state;\n    const config = (0, networkConfig_1.default)(gatekeeperNetworkAddress);\n    const dispatchFetch = () => ({\n        type: 'getGatekeeperRecord',\n    });\n    const dispatchFailure = () => ({\n        type: 'getGatekeeperRecord_failure',\n        gatekeeperRecord: { state: types_1.GatekeeperRecordState.SERVER_FAILURE, payload: undefined },\n    });\n    const dispatchSuccess = (record) => ({\n        type: 'getGatekeeperRecord_success',\n        gatekeeperRecord: record,\n    });\n    const dispatchLocationNotSupported = (record) => ({\n        type: 'getGatekeeperRecord_location_not_supported',\n        gatekeeperRecord: record,\n    });\n    const dispatchIssuedLocationNotSupported = (record) => ({\n        type: 'getGatekeeperRecord_issued_location_not_supported',\n        gatekeeperRecord: record,\n    });\n    const dispatchRecordNotFound = (record) => ({\n        type: 'getGatekeeperRecord_not_found',\n        gatekeeperRecord: record,\n    });\n    const getAction = (gatekeeperRecordState) => {\n        const actions = {\n            [types_1.GatekeeperRecordState.REQUESTED]: () => dispatchSuccess(gatekeeperRecordState),\n            [types_1.GatekeeperRecordState.ISSUED]: () => dispatchSuccess(gatekeeperRecordState),\n            [types_1.GatekeeperRecordState.ISSUED_EXPIRED]: () => dispatchSuccess(gatekeeperRecordState),\n            [types_1.GatekeeperRecordState.ISSUED_EXPIRY_APPROACHING]: () => dispatchSuccess(gatekeeperRecordState),\n            [types_1.GatekeeperRecordState.ISSUED_LOCATION_NOT_SUPPORTED]: () => dispatchIssuedLocationNotSupported(gatekeeperRecordState),\n            [types_1.GatekeeperRecordState.LOCATION_NOT_SUPPORTED]: () => dispatchLocationNotSupported(gatekeeperRecordState),\n            [types_1.GatekeeperRecordState.NOT_REQUESTED]: () => dispatchRecordNotFound(gatekeeperRecordState),\n        };\n        return actions[gatekeeperRecordState.state];\n    };\n    /**\n     * Check to see if there is getGatekeeperRecord and dispatch actions based on the state of the record.\n     * If the service call fails dispatch a failure.\n     */\n    const dispatchGatekeeperRecord = async () => {\n        const walletAddress = expectWalletConnected();\n        logDebug('Fetching Gatekeeper record');\n        dispatch(dispatchFetch());\n        try {\n            const record = await gatekeeperClient().getGatekeeperRecordWithPayload(walletAddress.publicKey);\n            logDebug('Gatekeeper record response state: ', types_1.GatekeeperRecordState[record.state]);\n            const action = getAction(record);\n            if (!action) {\n                logger_1.default.error('Cannot dispatch action for invalid Gatekeeper Record State.', { record });\n                return;\n            }\n            dispatch(action());\n        }\n        catch (error) {\n            logger_1.default.error('Failed to fetch Gatekeeper record', error);\n            dispatch(dispatchFailure());\n            throw error;\n        }\n    };\n    const useHttpConfigRef = (newHttpConfig) => {\n        const ref = (0, react_1.useRef)();\n        // We have to perform a deep equality check, otherwise useEffect will run every time the httpConfig object reference changes.\n        if (!R.equals(newHttpConfig, ref.current)) {\n            ref.current = newHttpConfig;\n        }\n        return ref.current;\n    };\n    (0, react_1.useEffect)(() => {\n        if (config.requiresGatekeeperRecordStatusCheck) {\n            dispatchGatekeeperRecord();\n        }\n    }, [\n        gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.state,\n        gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime,\n        gatekeeperNetworkAddress,\n        useHttpConfigRef(httpConfig),\n        config.requiresGatekeeperRecordStatusCheck,\n    ]);\n    return { dispatchGatekeeperRecord };\n};\nexports.default = useGetGatekeeperRecord;\n"]},"metadata":{},"sourceType":"script"}