{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shouldRefreshToken = void 0;\n\nconst react_1 = require(\"react\");\n\nconst config_1 = require(\"../solana/config\");\n\nconst logger_1 = __importDefault(require(\"../logger\"));\n\nconst types_1 = require(\"../types\");\n\nconst useChain_1 = __importDefault(require(\"./useChain\"));\n\nconst useRefresh_1 = __importDefault(require(\"./useRefresh\"));\n\nconst useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\n\nconst actionCreator_1 = require(\"../actionCreator\");\n\nconst usePOWO_1 = __importDefault(require(\"./usePOWO\"));\n\nconst useGatekeeper_1 = __importDefault(require(\"./useGatekeeper\"));\n\nconst useGatekeeperRecord_1 = __importDefault(require(\"./useGatekeeperRecord\"));\n\nconst networkConfig_1 = __importDefault(require(\"../networkConfig\"));\n\nconst shouldRefreshToken = async (state, gatewayToken, useWallet, powoRequested) => {\n  if (!gatewayToken) return false;\n  if (gatewayToken.state !== types_1.State.ACTIVE) return false;\n  if (!useWallet || !useWallet.publicKey || powoRequested) return false;\n  return state !== types_1.GatekeeperRecordState.ISSUED;\n};\n\nexports.shouldRefreshToken = shouldRefreshToken;\n/**\n * The orchestrator hook handles the main business logic of the component handling 2 main scenarios:\n * 1. the creation of a new gateway token for a new user\n * 2. the refreshing of an existing token for an existing user\n *\n * The orchestrator triggers uses effects to trigger flows for these two scenarios\n *\n * @param {{ wallet: WalletAdapter | undefined; clusterUrl: string; gatekeeperNetworkAddress: string | undefined; stage: string }} param0\n * @param {Partial<RootState>} state\n * @param {React.Dispatch<Action>} dispatch\n * @returns void\n */\n\nconst useOrchestration = (_ref, state, dispatch) => {\n  let {\n    wallet,\n    stage,\n    chainImplementation,\n    gatekeeperClient\n  } = _ref;\n  const {\n    expectWalletConnected\n  } = (0, useWalletHooks_1.default)(wallet, state, dispatch);\n  const gatekeeperEndpoint = (0, config_1.getGatekeeperEndpoint)(stage); // Register our hooks here\n\n  const {\n    setRefreshPoll,\n    refreshTokenWithProof\n  } = (0, useRefresh_1.default)({\n    stage,\n    gatekeeperClient\n  }, state, dispatch);\n  const {\n    waitForConfirmPOWO,\n    waitForPOWO\n  } = (0, usePOWO_1.default)({\n    wallet,\n    chainImplementation\n  }, state, dispatch);\n  const {\n    waitForGatekeeperIssuanceRequest\n  } = (0, useGatekeeper_1.default)({\n    wallet,\n    stage,\n    gatekeeperClient\n  }, state, dispatch);\n  (0, useGatekeeperRecord_1.default)({\n    wallet,\n    gatekeeperClient,\n    httpConfig: chainImplementation.httpConfig\n  }, state, dispatch);\n  (0, useChain_1.default)({\n    wallet,\n    chainImplementation\n  }, state, dispatch);\n  const {\n    gatewayToken,\n    tokenRequested,\n    refreshIntervalId,\n    powoRequested,\n    refreshInProgress,\n    walletToRefresh,\n    civicPass,\n    refreshTokenState,\n    gatewayStatus,\n    gatekeeperNetworkAddress\n  } = state;\n  /**\n   * Refresh Flows ----------------------------------------------------------------\n   */\n\n  /**\n   * poll until an unexpired gateway token is found\n   */\n\n  const waitForUnexpiredOnChainGatewayToken = (0, react_1.useCallback)(async () => {\n    if (wallet) {\n      logger_1.default.debug('waitForOnChainTokenAndNotExpiredToken');\n      const actionCreator = (0, actionCreator_1.gatewayTokenActionCreator)({\n        wallet,\n        chainImplementation,\n        gatekeeperClient,\n        dispatch,\n        networkConfig: (0, networkConfig_1.default)(gatekeeperNetworkAddress)\n      });\n      await actionCreator.waitForUnexpiredOnChainGatewayToken();\n    }\n\n    return null;\n  }, [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);\n  /**\n   * wait until we have a payload that has been emitted by the CivicPass iframe\n   * then resolve the promise\n   */\n\n  const waitForCivicPassRefreshResponsePayload = (0, react_1.useCallback)(() => {\n    expectWalletConnected();\n    logger_1.default.debug('waitForCivicPassRefreshResponsePayload');\n    const result = new Promise(resolve => {\n      const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n      const refreshPayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.REFRESH];\n      logger_1.default.debug('Refresh payload...', {\n        refreshPayload,\n        refreshPayloadState: refreshPayload === undefined\n      });\n\n      if (refreshPayload !== undefined) {\n        logger_1.default.debug('Refreshing token...');\n        resolve(refreshPayload);\n      }\n    });\n    return result;\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n  /**\n   * wait until a gateway token exists in state before resolving the promise\n   */\n\n  const waitForGatewayToken = (0, react_1.useCallback)(() => {\n    expectWalletConnected();\n    return new Promise(resolve => {\n      logger_1.default.debug('waitForGatewayToken gatewayToken', !!gatewayToken);\n      if (gatewayToken) resolve(gatewayToken);\n    });\n  }, [gatewayToken, expectWalletConnected]);\n  const checkRefreshRequired = (0, react_1.useCallback)(async connectedWallet => {\n    const useWallet = walletToRefresh || connectedWallet; // prefer the wallet set in state, this handles polling after disconnect\n    // Check preconditions for refresh:\n\n    await waitForGatewayToken();\n    if (!gatewayToken) return;\n    const record = await gatekeeperClient().getGatekeeperRecordWithPayload(gatewayToken.owner);\n    const shouldRefresh = await (0, exports.shouldRefreshToken)(record.state, gatewayToken, useWallet, powoRequested);\n    dispatch({\n      type: 'getGatekeeperRecord_success',\n      gatekeeperRecord: record\n    });\n\n    if (!shouldRefresh) {\n      logger_1.default.debug('Refresh not needed. Skipping this attempt.');\n      dispatch({\n        type: 'refresh_complete'\n      });\n      setRefreshPoll(useWallet);\n      return;\n    }\n\n    logger_1.default.debug('Refresh required. Running the refresh flow.');\n    clearInterval(refreshIntervalId);\n    dispatch({\n      type: 'refresh_start'\n    });\n    dispatch({\n      type: 'civicPass_check_token_status'\n    });\n    dispatch({\n      type: 'refresh_clear_interval'\n    });\n  }, [gatekeeperEndpoint, gatewayToken, powoRequested, refreshInProgress, refreshIntervalId, wallet, walletToRefresh]);\n  /**\n   * Check if the user needs to refresh their roken\n   */\n\n  (0, react_1.useEffect)(() => {\n    if (refreshTokenState === types_1.RefreshTokenState.CHECK_TOKEN_EXPIRATION) {\n      logger_1.default.debug('Checking if refresh required');\n      checkRefreshRequired();\n    }\n  }, [refreshTokenState]);\n  /**\n   * If the user cancels out of the refresh flow start the refresh interval\n   */\n\n  (0, react_1.useEffect)(() => {\n    if (refreshTokenState === types_1.RefreshTokenState.CANCELLED || refreshTokenState === types_1.RefreshTokenState.FAILED) {\n      logger_1.default.debug('User canceled out of the refresh flow');\n      setRefreshPoll(wallet);\n    }\n  }, [refreshTokenState]);\n  /**\n   * When we have a token start polling to determine the refresh state\n   */\n\n  (0, react_1.useEffect)(() => {\n    if (gatewayStatus === types_1.GatewayStatus.ACTIVE) {\n      logger_1.default.debug('Start polling for the record');\n      setRefreshPoll(wallet);\n    }\n  }, [gatewayStatus]);\n  /**\n   * Issuance Flows ----------------------------------------------------------------\n   */\n\n  /**\n   * poll until a gatekeeper record is found, once active check the chain for a token\n   * then dispatch a tokenChange event that will result in the token getting saved to state\n   * start token refresh polling once a valid token is set\n   */\n\n  const waitForOnChainToken = (0, react_1.useCallback)(async () => {\n    if (wallet) {\n      logger_1.default.debug('waitForOnChainToken');\n      const actionCreator = (0, actionCreator_1.gatewayTokenActionCreator)({\n        wallet,\n        chainImplementation,\n        gatekeeperClient,\n        dispatch,\n        networkConfig: (0, networkConfig_1.default)(gatekeeperNetworkAddress)\n      });\n      await actionCreator.waitForGatewayToken();\n    }\n\n    return null;\n  }, [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);\n  /**\n   * wait until a presentation request id has been emitted by the CivicPass iframe\n   * then resolve the promise\n   */\n\n  const waitForCivicPassIssuanceResponsePayload = (0, react_1.useCallback)(() => {\n    expectWalletConnected();\n    logger_1.default.debug('waitForCivicPassIssuanceResponsePayload');\n    const result = new Promise(resolve => {\n      const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n      const issuancePayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.ISSUANCE];\n      logger_1.default.debug('Issuance payload...', issuancePayload);\n\n      if (issuancePayload !== undefined) {\n        resolve(issuancePayload);\n      }\n    });\n    return result;\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n  /**\n   * wait until the user has requested a gateway token before resolving the promise\n   */\n\n  const waitForTokenRequested = (0, react_1.useCallback)(() => {\n    expectWalletConnected();\n    return new Promise(resolve => {\n      logger_1.default.debug('waitForTokenRequested tokenRequested', tokenRequested);\n      if (tokenRequested) resolve(true);\n    });\n  }, [tokenRequested, expectWalletConnected]);\n  /**\n   * wait until the user has requested a gateway token before resolving the promise\n   */\n\n  const checkForRequiredProof = (0, react_1.useCallback)(async _ref2 => {\n    let {\n      requiresProofOfWalletOwnership,\n      payload\n    } = _ref2;\n\n    if (requiresProofOfWalletOwnership) {\n      const result = await waitForConfirmPOWO(payload).then(waitForPOWO);\n      return result;\n    }\n\n    return {\n      payload\n    };\n  }, [waitForConfirmPOWO, waitForPOWO]);\n  /**\n   * New token request flow:\n   * wait for the user to request a new token\n   * wait for the iframe to return a payload\n   * wait for the user to confirm they've read the proof of ownership dialogue\n   * wait for the user to provide proof of ownership\n   * wait for a call to the gatekeeper to request a new token issuance\n   * wait for a gatekeeper record to be created\n   * once this flow is complete a new Gatekeeper token should be available and set in state\n   */\n\n  (0, react_1.useEffect)(() => {\n    waitForTokenRequested().then(waitForCivicPassIssuanceResponsePayload).then(checkForRequiredProof).then(waitForGatekeeperIssuanceRequest).then(waitForOnChainToken).then(() => setRefreshPoll(wallet)).catch(error => logger_1.default.error('ERROR newTokenRequestFlow', error));\n  }, [waitForTokenRequested, waitForCivicPassIssuanceResponsePayload, checkForRequiredProof, waitForGatekeeperIssuanceRequest, waitForOnChainToken]);\n  /**\n   * Refresh flow:\n   * wait refresh to be triggered from the iFrame\n   * wait for the iframe to return a payload\n   * wait for the user to confirm they've read the proof of ownership dialogue\n   * wait for the user to provide proof of ownership\n   * wait for a call to the gatekeeper to refresh the token\n   * start the polling interval\n   */\n\n  (0, react_1.useEffect)(() => {\n    const useWallet = walletToRefresh || wallet;\n    waitForCivicPassRefreshResponsePayload().then(checkForRequiredProof).then(refreshTokenWithProof(useWallet)).then(waitForUnexpiredOnChainGatewayToken).then(() => setRefreshPoll(useWallet)).then(() => {\n      dispatch({\n        type: 'refresh_complete'\n      });\n    }).catch(error => {\n      logger_1.default.error('refreshFlow', error);\n      logger_1.default.error('refreshToken error', error);\n      dispatch({\n        type: 'refresh_complete'\n      });\n      setRefreshPoll(useWallet);\n    });\n  }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, checkForRequiredProof, waitForUnexpiredOnChainGatewayToken]);\n};\n\nexports.default = useOrchestration;","map":{"version":3,"sources":["/Users/shawn/metaplex/js/packages/candy-machine-ui/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useOrchestration.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","shouldRefreshToken","react_1","require","config_1","logger_1","types_1","useChain_1","useRefresh_1","useWalletHooks_1","actionCreator_1","usePOWO_1","useGatekeeper_1","useGatekeeperRecord_1","networkConfig_1","state","gatewayToken","useWallet","powoRequested","State","ACTIVE","publicKey","GatekeeperRecordState","ISSUED","useOrchestration","dispatch","wallet","stage","chainImplementation","gatekeeperClient","expectWalletConnected","default","gatekeeperEndpoint","getGatekeeperEndpoint","setRefreshPoll","refreshTokenWithProof","waitForConfirmPOWO","waitForPOWO","waitForGatekeeperIssuanceRequest","httpConfig","tokenRequested","refreshIntervalId","refreshInProgress","walletToRefresh","civicPass","refreshTokenState","gatewayStatus","gatekeeperNetworkAddress","waitForUnexpiredOnChainGatewayToken","useCallback","debug","actionCreator","gatewayTokenActionCreator","networkConfig","waitForCivicPassRefreshResponsePayload","result","Promise","resolve","responsePayload","refreshPayload","CivicPassMessageAction","REFRESH","refreshPayloadState","undefined","waitForGatewayToken","checkRefreshRequired","connectedWallet","record","getGatekeeperRecordWithPayload","owner","shouldRefresh","type","gatekeeperRecord","clearInterval","useEffect","RefreshTokenState","CHECK_TOKEN_EXPIRATION","CANCELLED","FAILED","GatewayStatus","waitForOnChainToken","waitForCivicPassIssuanceResponsePayload","issuancePayload","ISSUANCE","waitForTokenRequested","checkForRequiredProof","requiresProofOfWalletOwnership","payload","then","catch","error"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.shouldRefreshToken = void 0;\nconst react_1 = require(\"react\");\nconst config_1 = require(\"../solana/config\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst types_1 = require(\"../types\");\nconst useChain_1 = __importDefault(require(\"./useChain\"));\nconst useRefresh_1 = __importDefault(require(\"./useRefresh\"));\nconst useWalletHooks_1 = __importDefault(require(\"./useWalletHooks\"));\nconst actionCreator_1 = require(\"../actionCreator\");\nconst usePOWO_1 = __importDefault(require(\"./usePOWO\"));\nconst useGatekeeper_1 = __importDefault(require(\"./useGatekeeper\"));\nconst useGatekeeperRecord_1 = __importDefault(require(\"./useGatekeeperRecord\"));\nconst networkConfig_1 = __importDefault(require(\"../networkConfig\"));\nconst shouldRefreshToken = async (state, gatewayToken, useWallet, powoRequested) => {\n    if (!gatewayToken)\n        return false;\n    if (gatewayToken.state !== types_1.State.ACTIVE)\n        return false;\n    if (!useWallet || !useWallet.publicKey || powoRequested)\n        return false;\n    return state !== types_1.GatekeeperRecordState.ISSUED;\n};\nexports.shouldRefreshToken = shouldRefreshToken;\n/**\n * The orchestrator hook handles the main business logic of the component handling 2 main scenarios:\n * 1. the creation of a new gateway token for a new user\n * 2. the refreshing of an existing token for an existing user\n *\n * The orchestrator triggers uses effects to trigger flows for these two scenarios\n *\n * @param {{ wallet: WalletAdapter | undefined; clusterUrl: string; gatekeeperNetworkAddress: string | undefined; stage: string }} param0\n * @param {Partial<RootState>} state\n * @param {React.Dispatch<Action>} dispatch\n * @returns void\n */\nconst useOrchestration = ({ wallet, stage, chainImplementation, gatekeeperClient, }, state, dispatch) => {\n    const { expectWalletConnected } = (0, useWalletHooks_1.default)(wallet, state, dispatch);\n    const gatekeeperEndpoint = (0, config_1.getGatekeeperEndpoint)(stage);\n    // Register our hooks here\n    const { setRefreshPoll, refreshTokenWithProof } = (0, useRefresh_1.default)({ stage, gatekeeperClient }, state, dispatch);\n    const { waitForConfirmPOWO, waitForPOWO } = (0, usePOWO_1.default)({ wallet, chainImplementation }, state, dispatch);\n    const { waitForGatekeeperIssuanceRequest } = (0, useGatekeeper_1.default)({ wallet, stage, gatekeeperClient }, state, dispatch);\n    (0, useGatekeeperRecord_1.default)({ wallet, gatekeeperClient, httpConfig: chainImplementation.httpConfig }, state, dispatch);\n    (0, useChain_1.default)({ wallet, chainImplementation }, state, dispatch);\n    const { gatewayToken, tokenRequested, refreshIntervalId, powoRequested, refreshInProgress, walletToRefresh, civicPass, refreshTokenState, gatewayStatus, gatekeeperNetworkAddress, } = state;\n    /**\n     * Refresh Flows ----------------------------------------------------------------\n     */\n    /**\n     * poll until an unexpired gateway token is found\n     */\n    const waitForUnexpiredOnChainGatewayToken = (0, react_1.useCallback)(async () => {\n        if (wallet) {\n            logger_1.default.debug('waitForOnChainTokenAndNotExpiredToken');\n            const actionCreator = (0, actionCreator_1.gatewayTokenActionCreator)({\n                wallet,\n                chainImplementation,\n                gatekeeperClient,\n                dispatch,\n                networkConfig: (0, networkConfig_1.default)(gatekeeperNetworkAddress),\n            });\n            await actionCreator.waitForUnexpiredOnChainGatewayToken();\n        }\n        return null;\n    }, [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);\n    /**\n     * wait until we have a payload that has been emitted by the CivicPass iframe\n     * then resolve the promise\n     */\n    const waitForCivicPassRefreshResponsePayload = (0, react_1.useCallback)(() => {\n        expectWalletConnected();\n        logger_1.default.debug('waitForCivicPassRefreshResponsePayload');\n        const result = new Promise((resolve) => {\n            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n            const refreshPayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.REFRESH];\n            logger_1.default.debug('Refresh payload...', {\n                refreshPayload,\n                refreshPayloadState: refreshPayload === undefined,\n            });\n            if (refreshPayload !== undefined) {\n                logger_1.default.debug('Refreshing token...');\n                resolve(refreshPayload);\n            }\n        });\n        return result;\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n    /**\n     * wait until a gateway token exists in state before resolving the promise\n     */\n    const waitForGatewayToken = (0, react_1.useCallback)(() => {\n        expectWalletConnected();\n        return new Promise((resolve) => {\n            logger_1.default.debug('waitForGatewayToken gatewayToken', !!gatewayToken);\n            if (gatewayToken)\n                resolve(gatewayToken);\n        });\n    }, [gatewayToken, expectWalletConnected]);\n    const checkRefreshRequired = (0, react_1.useCallback)(async (connectedWallet) => {\n        const useWallet = walletToRefresh || connectedWallet; // prefer the wallet set in state, this handles polling after disconnect\n        // Check preconditions for refresh:\n        await waitForGatewayToken();\n        if (!gatewayToken)\n            return;\n        const record = await gatekeeperClient().getGatekeeperRecordWithPayload(gatewayToken.owner);\n        const shouldRefresh = await (0, exports.shouldRefreshToken)(record.state, gatewayToken, useWallet, powoRequested);\n        dispatch({ type: 'getGatekeeperRecord_success', gatekeeperRecord: record });\n        if (!shouldRefresh) {\n            logger_1.default.debug('Refresh not needed. Skipping this attempt.');\n            dispatch({ type: 'refresh_complete' });\n            setRefreshPoll(useWallet);\n            return;\n        }\n        logger_1.default.debug('Refresh required. Running the refresh flow.');\n        clearInterval(refreshIntervalId);\n        dispatch({ type: 'refresh_start' });\n        dispatch({ type: 'civicPass_check_token_status' });\n        dispatch({ type: 'refresh_clear_interval' });\n    }, [gatekeeperEndpoint, gatewayToken, powoRequested, refreshInProgress, refreshIntervalId, wallet, walletToRefresh]);\n    /**\n     * Check if the user needs to refresh their roken\n     */\n    (0, react_1.useEffect)(() => {\n        if (refreshTokenState === types_1.RefreshTokenState.CHECK_TOKEN_EXPIRATION) {\n            logger_1.default.debug('Checking if refresh required');\n            checkRefreshRequired();\n        }\n    }, [refreshTokenState]);\n    /**\n     * If the user cancels out of the refresh flow start the refresh interval\n     */\n    (0, react_1.useEffect)(() => {\n        if (refreshTokenState === types_1.RefreshTokenState.CANCELLED || refreshTokenState === types_1.RefreshTokenState.FAILED) {\n            logger_1.default.debug('User canceled out of the refresh flow');\n            setRefreshPoll(wallet);\n        }\n    }, [refreshTokenState]);\n    /**\n     * When we have a token start polling to determine the refresh state\n     */\n    (0, react_1.useEffect)(() => {\n        if (gatewayStatus === types_1.GatewayStatus.ACTIVE) {\n            logger_1.default.debug('Start polling for the record');\n            setRefreshPoll(wallet);\n        }\n    }, [gatewayStatus]);\n    /**\n     * Issuance Flows ----------------------------------------------------------------\n     */\n    /**\n     * poll until a gatekeeper record is found, once active check the chain for a token\n     * then dispatch a tokenChange event that will result in the token getting saved to state\n     * start token refresh polling once a valid token is set\n     */\n    const waitForOnChainToken = (0, react_1.useCallback)(async () => {\n        if (wallet) {\n            logger_1.default.debug('waitForOnChainToken');\n            const actionCreator = (0, actionCreator_1.gatewayTokenActionCreator)({\n                wallet,\n                chainImplementation,\n                gatekeeperClient,\n                dispatch,\n                networkConfig: (0, networkConfig_1.default)(gatekeeperNetworkAddress),\n            });\n            await actionCreator.waitForGatewayToken();\n        }\n        return null;\n    }, [gatekeeperEndpoint, gatekeeperClient, expectWalletConnected]);\n    /**\n     * wait until a presentation request id has been emitted by the CivicPass iframe\n     * then resolve the promise\n     */\n    const waitForCivicPassIssuanceResponsePayload = (0, react_1.useCallback)(() => {\n        expectWalletConnected();\n        logger_1.default.debug('waitForCivicPassIssuanceResponsePayload');\n        const result = new Promise((resolve) => {\n            const responsePayload = civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload;\n            const issuancePayload = responsePayload && responsePayload[types_1.CivicPassMessageAction.ISSUANCE];\n            logger_1.default.debug('Issuance payload...', issuancePayload);\n            if (issuancePayload !== undefined) {\n                resolve(issuancePayload);\n            }\n        });\n        return result;\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, expectWalletConnected]);\n    /**\n     * wait until the user has requested a gateway token before resolving the promise\n     */\n    const waitForTokenRequested = (0, react_1.useCallback)(() => {\n        expectWalletConnected();\n        return new Promise((resolve) => {\n            logger_1.default.debug('waitForTokenRequested tokenRequested', tokenRequested);\n            if (tokenRequested)\n                resolve(true);\n        });\n    }, [tokenRequested, expectWalletConnected]);\n    /**\n     * wait until the user has requested a gateway token before resolving the promise\n     */\n    const checkForRequiredProof = (0, react_1.useCallback)(async ({ requiresProofOfWalletOwnership, payload, }) => {\n        if (requiresProofOfWalletOwnership) {\n            const result = await waitForConfirmPOWO(payload).then(waitForPOWO);\n            return result;\n        }\n        return { payload };\n    }, [waitForConfirmPOWO, waitForPOWO]);\n    /**\n     * New token request flow:\n     * wait for the user to request a new token\n     * wait for the iframe to return a payload\n     * wait for the user to confirm they've read the proof of ownership dialogue\n     * wait for the user to provide proof of ownership\n     * wait for a call to the gatekeeper to request a new token issuance\n     * wait for a gatekeeper record to be created\n     * once this flow is complete a new Gatekeeper token should be available and set in state\n     */\n    (0, react_1.useEffect)(() => {\n        waitForTokenRequested()\n            .then(waitForCivicPassIssuanceResponsePayload)\n            .then(checkForRequiredProof)\n            .then(waitForGatekeeperIssuanceRequest)\n            .then(waitForOnChainToken)\n            .then(() => setRefreshPoll(wallet))\n            .catch((error) => logger_1.default.error('ERROR newTokenRequestFlow', error));\n    }, [\n        waitForTokenRequested,\n        waitForCivicPassIssuanceResponsePayload,\n        checkForRequiredProof,\n        waitForGatekeeperIssuanceRequest,\n        waitForOnChainToken,\n    ]);\n    /**\n     * Refresh flow:\n     * wait refresh to be triggered from the iFrame\n     * wait for the iframe to return a payload\n     * wait for the user to confirm they've read the proof of ownership dialogue\n     * wait for the user to provide proof of ownership\n     * wait for a call to the gatekeeper to refresh the token\n     * start the polling interval\n     */\n    (0, react_1.useEffect)(() => {\n        const useWallet = walletToRefresh || wallet;\n        waitForCivicPassRefreshResponsePayload()\n            .then(checkForRequiredProof)\n            .then(refreshTokenWithProof(useWallet))\n            .then(waitForUnexpiredOnChainGatewayToken)\n            .then(() => setRefreshPoll(useWallet))\n            .then(() => {\n            dispatch({ type: 'refresh_complete' });\n        })\n            .catch((error) => {\n            logger_1.default.error('refreshFlow', error);\n            logger_1.default.error('refreshToken error', error);\n            dispatch({ type: 'refresh_complete' });\n            setRefreshPoll(useWallet);\n        });\n    }, [civicPass === null || civicPass === void 0 ? void 0 : civicPass.responsePayload, checkForRequiredProof, waitForUnexpiredOnChainGatewayToken]);\n};\nexports.default = useOrchestration;\n"]},"metadata":{},"sourceType":"script"}