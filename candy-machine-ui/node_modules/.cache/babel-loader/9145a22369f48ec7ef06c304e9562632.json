{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GatewayTokenActionCreatorImplementation = void 0;\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nconst solana_gateway_ts_1 = require(\"@identity.com/solana-gateway-ts\");\n\nconst types_1 = require(\"../types\");\n\nconst logger_1 = __importDefault(require(\"../logger\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst tokenUtils_1 = require(\"../utils/tokenUtils\");\n\nconst GatewayTokenActionCreatorImplementation = _ref => {\n  let {\n    wallet,\n    chainImplementation,\n    gatekeeperClient,\n    dispatch,\n    networkConfig\n  } = _ref;\n\n  const logDebug = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(`[useChain] ${message}`, obj);\n  };\n\n  const logError = function (message) {\n    let obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.error(`[useChain] ${message}`, obj);\n  };\n\n  const isTokenCreated = code => code === 200;\n\n  const isTokenPending = code => code === 202 || code === 404;\n\n  const isFailure = code => !isTokenPending(code) && code >= 400;\n\n  const pollForActiveOnChainToken = async () => {\n    return (0, utils_1.pollUntilConditionMet)(chainImplementation.findGatewayToken, onChainToken => {\n      if (!onChainToken) return false; // keep polling\n\n      if (!onChainToken.expiryTime) return true;\n      if (onChainToken.state === solana_gateway_ts_1.State.ACTIVE) return true;\n      throw new Error('Token found but not ACTIVE');\n    }, networkConfig.pollChainIntervalMilliseconds, networkConfig.pollChainNumberRetries);\n  };\n\n  const pollForUnExpiredOnChainToken = async () => {\n    return (0, utils_1.pollUntilConditionMet)(chainImplementation.findGatewayToken, onChainToken => {\n      if (!(onChainToken === null || onChainToken === void 0 ? void 0 : onChainToken.expiryTime) || !(0, tokenUtils_1.hasExpired)(onChainToken.expiryTime)) return true;\n      return false;\n    }, networkConfig.pollChainIntervalMilliseconds, networkConfig.pollChainNumberRetries);\n  };\n\n  const waitForGatewayToken = async () => {\n    // poll the gatekeeper until we have a status for a created record\n    // if we don't get a created token, then we consider it a failure\n    try {\n      const token = await pollForActiveOnChainToken();\n      logDebug('Result from pollForActiveOnChainToken', token);\n\n      if (!token) {\n        logError('Token not found onChain');\n        throw new Error('Token not found onChain');\n      }\n\n      dispatch({\n        type: 'tokenChange',\n        token\n      });\n      dispatch({\n        type: 'civicPass_check_token_status',\n        token\n      });\n      return;\n    } catch (error) {\n      logError('Failed to find Gateway token on-chain, checking with gatekeeper');\n      const state = await gatekeeperClient().getGatekeeperStatus(wallet.publicKey); // if the token is still pending or in review then keep polling on-chain\n\n      if (isTokenPending(state)) {\n        await waitForGatewayToken();\n      } // retries have been exhausted and we still don't have a token\n      // or the gatekeeper threw an error during issuance attempt\n\n\n      if (isTokenCreated(state) || isFailure(state)) {\n        logError('Failed to find Gateway token with gatekeeper status code', types_1.GatekeeperRecordState[state]);\n        dispatch({\n          type: 'tokenNotFoundError'\n        });\n      }\n    }\n  };\n\n  return {\n    waitForGatewayToken,\n    waitForUnexpiredOnChainGatewayToken: pollForUnExpiredOnChainToken\n  };\n};\n\nexports.GatewayTokenActionCreatorImplementation = GatewayTokenActionCreatorImplementation;","map":{"version":3,"sources":["/Users/shawn/metaplex/js/packages/candy-machine-ui/node_modules/@civic/solana-gateway-react/dist/esm/actionCreator/gatewayToken.actionCreator.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","GatewayTokenActionCreatorImplementation","solana_gateway_ts_1","require","types_1","logger_1","utils_1","tokenUtils_1","wallet","chainImplementation","gatekeeperClient","dispatch","networkConfig","logDebug","message","obj","default","debug","logError","error","isTokenCreated","code","isTokenPending","isFailure","pollForActiveOnChainToken","pollUntilConditionMet","findGatewayToken","onChainToken","expiryTime","state","State","ACTIVE","Error","pollChainIntervalMilliseconds","pollChainNumberRetries","pollForUnExpiredOnChainToken","hasExpired","waitForGatewayToken","token","type","getGatekeeperStatus","publicKey","GatekeeperRecordState","waitForUnexpiredOnChainGatewayToken"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GatewayTokenActionCreatorImplementation = void 0;\n/* eslint-disable @typescript-eslint/no-unused-vars */\nconst solana_gateway_ts_1 = require(\"@identity.com/solana-gateway-ts\");\nconst types_1 = require(\"../types\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst utils_1 = require(\"./utils\");\nconst tokenUtils_1 = require(\"../utils/tokenUtils\");\nconst GatewayTokenActionCreatorImplementation = ({ wallet, chainImplementation, gatekeeperClient, dispatch, networkConfig, }) => {\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useChain] ${message}`, obj);\n    const logError = (message, obj = null) => logger_1.default.error(`[useChain] ${message}`, obj);\n    const isTokenCreated = (code) => code === 200;\n    const isTokenPending = (code) => code === 202 || code === 404;\n    const isFailure = (code) => !isTokenPending(code) && code >= 400;\n    const pollForActiveOnChainToken = async () => {\n        return (0, utils_1.pollUntilConditionMet)(chainImplementation.findGatewayToken, (onChainToken) => {\n            if (!onChainToken)\n                return false; // keep polling\n            if (!onChainToken.expiryTime)\n                return true;\n            if (onChainToken.state === solana_gateway_ts_1.State.ACTIVE)\n                return true;\n            throw new Error('Token found but not ACTIVE');\n        }, networkConfig.pollChainIntervalMilliseconds, networkConfig.pollChainNumberRetries);\n    };\n    const pollForUnExpiredOnChainToken = async () => {\n        return (0, utils_1.pollUntilConditionMet)(chainImplementation.findGatewayToken, (onChainToken) => {\n            if (!(onChainToken === null || onChainToken === void 0 ? void 0 : onChainToken.expiryTime) || !(0, tokenUtils_1.hasExpired)(onChainToken.expiryTime))\n                return true;\n            return false;\n        }, networkConfig.pollChainIntervalMilliseconds, networkConfig.pollChainNumberRetries);\n    };\n    const waitForGatewayToken = async () => {\n        // poll the gatekeeper until we have a status for a created record\n        // if we don't get a created token, then we consider it a failure\n        try {\n            const token = await pollForActiveOnChainToken();\n            logDebug('Result from pollForActiveOnChainToken', token);\n            if (!token) {\n                logError('Token not found onChain');\n                throw new Error('Token not found onChain');\n            }\n            dispatch({ type: 'tokenChange', token });\n            dispatch({ type: 'civicPass_check_token_status', token });\n            return;\n        }\n        catch (error) {\n            logError('Failed to find Gateway token on-chain, checking with gatekeeper');\n            const state = await gatekeeperClient().getGatekeeperStatus(wallet.publicKey);\n            // if the token is still pending or in review then keep polling on-chain\n            if (isTokenPending(state)) {\n                await waitForGatewayToken();\n            }\n            // retries have been exhausted and we still don't have a token\n            // or the gatekeeper threw an error during issuance attempt\n            if (isTokenCreated(state) || isFailure(state)) {\n                logError('Failed to find Gateway token with gatekeeper status code', types_1.GatekeeperRecordState[state]);\n                dispatch({ type: 'tokenNotFoundError' });\n            }\n        }\n    };\n    return {\n        waitForGatewayToken,\n        waitForUnexpiredOnChainGatewayToken: pollForUnExpiredOnChainToken,\n    };\n};\nexports.GatewayTokenActionCreatorImplementation = GatewayTokenActionCreatorImplementation;\n"]},"metadata":{},"sourceType":"script"}