"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reducer = void 0;
const react_1 = require("react");
const utils_1 = require("../useReducer/utils");
const config_1 = require("../config");
const logger_1 = __importDefault(require("../logger"));
const types_1 = require("../types");
const reducer = (state, action) => {
    switch (action.type) {
        case 'refresh_status_check': {
            return Object.assign(Object.assign({}, state), { walletPowoInProgress: false, powoFinished: false, powoRequested: undefined, refreshInProgress: true, refreshIntervalId: action.refreshIntervalId, walletToRefresh: action.walletToRefresh, refreshTokenState: types_1.RefreshTokenState.CHECK_TOKEN_EXPIRATION });
        }
        case 'refresh_start': {
            return Object.assign(Object.assign({}, state), { gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED, refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS });
        }
        case 'refresh_complete': {
            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.COMPLETED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken), civicPass: Object.assign(Object.assign({}, state.civicPass), { responsePayload: undefined }) });
        }
        case 'refresh_with_powo_in_progress': {
            return Object.assign(Object.assign({}, state), { renderIframe: false, iframeMinimized: true, gatewayStatus: types_1.GatewayStatus.COLLECTING_USER_INFORMATION });
        }
        case 'refresh_clear_interval':
            return Object.assign(Object.assign({}, state), { refreshIntervalId: undefined });
        case 'refresh_set_interval':
            return Object.assign(Object.assign({}, state), { refreshIntervalId: action.refreshIntervalId });
        default:
            return state;
    }
};
exports.reducer = reducer;
const useRefresh = ({ stage, gatekeeperClient }, state, dispatch) => {
    const { refreshIntervalId, gatewayToken } = state;
    const logDebug = (message, obj = null) => logger_1.default.debug(`[useRefresh] ${message}`, obj);
    const logError = (message, obj = null) => logger_1.default.error(`[useRefresh] ${message}`, obj);
    /**
     * if a refresh interval hasn't already been set, create one that will dispatch the startRefresh
     * event, triggering the refreshFlow
     */
    const setRefreshPoll = (0, react_1.useCallback)((connectedWallet) => {
        if (!refreshIntervalId) {
            const interval = setInterval(() => {
                dispatch({
                    type: 'refresh_status_check',
                    refreshIntervalId: interval,
                    walletToRefresh: connectedWallet,
                });
            }, (0, config_1.getRefreshIntervalMs)(stage)); // this will be cleared on completion
            // We need to know that the interval was set even if it has not fired yet.
            // to avoid setting duplicate intervals.
            dispatch({
                type: 'refresh_set_interval',
                refreshIntervalId: interval,
            });
            logger_1.default.debug('setRefreshPoll setInterval', (0, config_1.getRefreshIntervalMs)(stage));
        }
    }, [refreshIntervalId, stage]);
    /**
     * use the passed proof of wallet ownership string to call the gatekeeper refresh token
     * endpoint.
     * On server error (5xx), retry with backoff.
     * On all other errors, e.g. 400, move to a REFRESH_FAILED state.
     */
    const refreshTokenWithProof = (0, react_1.useCallback)((useWallet) => ({ proof, payload }) => {
        return new Promise((resolve, reject) => {
            logDebug('Refresh token with proof', proof);
            if (gatewayToken) {
                dispatch({ type: 'refresh_with_powo_in_progress' });
                gatekeeperClient()
                    .refreshToken(gatewayToken.identifier, useWallet.publicKey, payload, proof)
                    .then(() => {
                    resolve();
                })
                    .catch((error) => {
                    logError('Error refreshing token with proof', error);
                    reject(error);
                });
            }
        });
    }, [gatewayToken, gatekeeperClient, setRefreshPoll]);
    return {
        setRefreshPoll,
        refreshTokenWithProof,
    };
};
exports.default = useRefresh;
